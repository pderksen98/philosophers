void	print_philosophers(t_philo *philo)
{
	int	i;

	i = 0;
	while (i < philo->rules->nb_of_philos)
	{
		printf("Philosopher %d:\n", philo[i].id);
		printf("	- left fork:  %d\n", philo[i].left_fork);
		printf("	- right fork: %d\n", philo[i].right_fork);
		i++;
	}
}


// void	print_args(t_rules rules)
// {
// 	printf("************  GENERAL RULES  ************\n");
// 	printf("# of philos:   %d\n", rules.nb_of_philos);
// 	printf("time to die:   %d [ms]\n", rules.time_to_die);
// 	printf("time to eat:   %d [ms]\n", rules.time_to_eat);
// 	printf("time to sleep: %d [ms]\n", rules.time_to_sleep);
// 	printf("# of meals:    %d\n", rules.nb_of_meals);
// 	printf("*****************************************\n\n");
// }
















void	create_s_philo(t_philo *s_philo, t_rules *rules, int i)
{
	s_philo->rules = rules;
	s_philo->id = i + 1;
	s_philo->times_eaten = 0;
	s_philo->start_time = get_current_time();
	s_philo->left_fork = i;
	if (s_philo->rules->nb_of_philos > 1)
	{
		if (s_philo->id != s_philo->rules->nb_of_philos)
			s_philo->right_fork = i + 1;
		else
			s_philo->right_fork = 0;
	}
	pthread_mutex_init(&s_philo->rules->forks[i], NULL);
}	


int	start_simulation(t_rules *rules)
{
	t_philo	*s_philo;
	int		i;

	s_philo = malloc(rules->nb_of_philos * sizeof(t_philo));
	if (!s_philo)
		return (ft_error("Failed to malloc s_philo struct\n"));
	i = 0;
	while (i < rules->nb_of_philos)
	{
		create_s_philo(&s_philo[i], rules, i);
		i++;
	}
		
	return (EXIT_SUCCESS);
}




























void	put_down_forks(t_philo *s_philo)
{
	pthread_mutex_lock(&s_philo->rules->forks[s_philo->left_fork]);
	pthread_mutex_lock(&s_philo->rules->forks[s_philo->right_fork]);
	printf("Philosopher %d has put down both forks\n", s_philo->id);
	pthread_mutex_unlock(&s_philo->rules->forks[s_philo->left_fork]);
	pthread_mutex_unlock(&s_philo->rules->forks[s_philo->right_fork]);
}

void	pick_up_forks(t_philo *s_philo)
{
		pthread_mutex_lock(&s_philo->rules->forks[s_philo->left_fork]);
		pthread_mutex_lock(&s_philo->rules->forks[s_philo->right_fork]);
		printf("Philosopher %d picked up both forks\n", s_philo->id);
		usleep(s_philo->rules->time_to_eat * 1000);
		pthread_mutex_unlock(&s_philo->rules->forks[s_philo->left_fork]);
		pthread_mutex_unlock(&s_philo->rules->forks[s_philo->right_fork]);
}

void	try_to_eat(t_philo *s_philo)
{
	while (1)
	{
		pick_up_forks(s_philo);
		put_down_forks(s_philo);
		printf("Sleepy time for philosopher %d\n", s_)
	}
}





DIT IS DE OUDE PICK FORKS UP FUNCTIE

int	pick_up_forks(t_philo *s_philo)
{
	if (s_philo->rules->fork_available[s_philo->left_fork] == 0 && \
			s_philo->rules->fork_available[s_philo->right_fork] == 0)	
	{
		pthread_mutex_lock(&s_philo->rules->forks[s_philo->left_fork]);
		s_philo->rules->fork_available[s_philo->left_fork] = 1;
		pthread_mutex_unlock(&s_philo->rules->forks[s_philo->left_fork]);
		pthread_mutex_lock(&s_philo->rules->forks[s_philo->right_fork]);
		s_philo->rules->fork_available[s_philo->right_fork] = 1;
		pthread_mutex_unlock(&s_philo->rules->forks[s_philo->right_fork]);
		return (1);
	}
	return (0);
}